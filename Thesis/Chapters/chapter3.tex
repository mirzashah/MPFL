\chapter{Overview of the \\Modular Planning Language and Framework}
This chapter gives a high level overview of the central topic of this thesis, the \textit{Modular Planning Language and Framework}.

\section{Redundancies in Autonomy Development}
Developing sophisticated autonomy software for a robot is a very difficult and expensive task. One snag is that it is common practice for developers to create customized autonomy software for each unique robot, its particular payload, and its intended purpose. One cannot take the autonomy software that runs on mobile robot \textit{A} and put it on a completely different mobile robot \textit{B} in a transparent manner, and expect \textit{B} to behave like \textit{A} (or even to work at all). This is because \textit{B} may have completely different sensors, propulsion system, onboard computer, and/or payload from \textit{A}. 

To solve this problem, developers of autonomy development frameworks try to create software abstractions that create a unified interface across multiple vehicles so software can be reused. For example, rather than worry about the details of how the drive system of a mobile robot works, one possible abstraction is to create an interface that allows the user to control the heading and speed of the robot, perhaps in the form of a software library. The developer of the drive system would be expected to provide the underlying implementation that maps to this common interface. If this interface is available across several different types of robots, higher level autonomy layers that utilize the interface do not need to be changed and can be ported transparently across to other robots. The concept is similar to the idea of system libraries and drivers in operating systems. The operating system defines high-level abstractions for the various types of devices that are expected to be used on the computer (e.g. mouse, video card). Hardware developers are expected to write drivers that match the interface defined by the operating system. Application developers can then utilize the device through the abstraction in the form of a standardized API , such as sockets for network communication and file I/O for non-volatile data storage. 

Creating common abstractions is more difficult in robotics than with operating systems. This is because robots are so varied in their design and application. Also unlike computer components that are highly standardized (e.g. Intel x86 ISA, USB, PCI, SCSI, VGA, Ethernet, etc), robotic hardware has not reached the same level of commoditization.  However, on the other hand there is significant commonality across robots particularly when one focuses on a specific class of robots. For example, there is a large amount of redundancy in the area of autonomous underwater vehicles (AUVs)\footnote{AUVs are a subset of unmanned underwater vehicles (UUVs), which can also include non-autonomous vehicles primarily \textit{remotely-operated underwater vehicles (ROVs)}}. Even though AUVs differ greatly in design, payload configurations, and their applications, their primitive functions are essentially the same: move around, sense things (primarily with sonar), operate various onboard payloads, deploy things, and collect things. There is even overlap with higher-level functionality. For example, it is typical to use AUVs to search for and/or monitor objects of interest. Take for instance an undersea warfare application where an AUV is searching for enemy submarines versus a marine biology experiment that is tracking whale migration patterns. Both will likely use similar techniques to detect, classify, and track those objects, whether it be a whale or an enemy sub\footnote{In the example of a whale versus a submarine, both the whale and submarine emit a unique sound signature that can be used to track them with passive sonar.}. Another example is bottom floor mapping where an AUV is used to create a detailed map of the ocean floor. In undersea warfare applications, this can be used to give manned submarines detailed navigational information so that they do not collide with the ocean floor, or perhaps to find more covert routes to traverse. In an energy exploration application, bottom mapping is used to look for potential places to drill for oil.

\section{Overview of the Modular Planning Framework and Language}
The \Definition{Modular Planning Framework and Language (MPFL)} is yet another attempt to create a tool to address the redundancy in the area of autonomous robot mission planning software. MPFL is a software framework that allows one to develop sophisticated, deliberative planning capabilities for an autonomous mobile robot in a straightforward, guided manner while providing guarantees regarding the operational correctness of the robot. MPFL not only gives a framework for control software developers to build robot autonomy, but it has explicit focus on component reuse. For example, if somebody wants to create a component for executing a search behavior in some autonomous robot \textit{X}, that component should have the ability to be reused transparently in another autonomous robot \textit{Y}, giving \textit{Y} the ability to perform that search behavior. A robot that utilizes MPFL can then be controlled via a special high-level, domain-specific programming language used to specify the goals, operating constraints, and error handling routines for the robot. This domain-specific programming language is known as the \Definition{MPFL Mission Specification Language (MSL)} and is the foundation of the entire framework.

\subsection{Planning is to Schedules as Compiling is to Machine Code}
The MSL is what makes MPFL powerful and unique. MPFL is a planning system embodied in the form of a compiler for a programming language (the MSL). Utilizing an artificial language to control the robot brings with it many of the advantages of domain-specific programming languages mentioned in the previous chapter, including strong domain-level verification and error handling mechanisms, an intuitive and natural way to control the vehicle, decoupling from a specific general purpose programming language, and a formal operational specification. MPFL's design was influenced by thinking of robotic planning as the compilation of code written in a high-level language (the MSL) to a lower-level representation. Compilers for a high-level general purpose programming languages (such as C or Java) typically compile to machine code for a particular machine instruction set architecture (ISA)\footnote{Languages that compile to an intermediate representation (e.g. Java bytecode) that is to be processed by a virtual machine (i.e. runtime interpreter) are also considered compiled.}. In contrast, MPFL translates a description of the mission specified by the user in the MSL into a set of \Definition{schedules} (\RefPicture{mpflhighlevel.png}). In MPFL, a schedule is simply a table of fine-grained, timestamped commands intended for a particular vehicle actuator or subsystem (e.g. sensors, drive system) (\RefPicture{mpflschedule.png}). If the robot follows the schedules, the result will be what the user specified in their MSL program.

\InsertPicture{mpflhighlevel.png}{0.35}{High level view of MPFL.}

\InsertPicture{mpflschedule.png}{0.35}{A typical MPFL schedule.}

Unlike typical compilers which are standalone applications, MPFL comes in the form of a software library where the compiler is invoked from an application that links against the library. An application which utilizes MPFL is referred to as an \Definition{MPFL client application} or simply \Definition{client}. The client is the glue between MPFL and the other components of the robot's autonomy software. The client is intended to run physically onboard the robot itself but may also run on a remote computer communicating planning data with the robot via a network link if onboard processing resources are not sufficient. The client may encompass all the autonomy of the vehicle or maybe one of many operating system processes running onboard the vehicle that constitute the whole autonomy software stack. Within the client, the user initializes the MPFL framework via an API call passing the name of a single source file containing their mission description written in the MSL. MPFL then parses the specification while performing static checks (e.g. type checking, enforcing scoping rules). If successful, the \Definition{MPFL compiler/runtime} (also can be referred to as the \Definition{MPFL compiler} or the \Definition{MPFL runtime}) is loaded into memory which stays resident until the client application has ended. The user can then ask MPFL to compile the mission specification code into a set of schedules. The schedules that are returned by MPFL to the client can then be used to control the vehicle. If the user follows the schedules carefully, the mission that was specified in the MSL can be accomplished.

What makes MPFL different from a normal compiler is that the job is not complete after a single compilation. The environment of robots is constantly changing and information the robot has can be erroneous or incomplete requiring replanning as newer and more complete information is acquired. For example, if a robot is asked to go to some waypoint within some time constraint, it may initially think the task can be done. However, halfway to the point the robot's sensors may pick up an obstacle requiring replanning so that the robot can move around the object. In MPFL, one can perform replanning simply by reinvoking the compiler from within the client periodically. The MPFL compiler/runtime is stateful so rescheduling takes into account partially and fully completed goals. The control software developer writing the MPFL client can choose to invoke the compiler as needed depending on their requirements.

\subsection{Expressiveness of the Mission Specification Language}
What makes MPFL unique is the MSL. The MSL is a highly declarative language where one can specify problems that seem really difficult but can be solved in a straightforward manner by MPFL. For example, with the MSL one can specify a seemingly complicated mission such as the following:


\begin{flushleft}
\textit{I have three physical regions \Code{A}, \Code{B}, and \Code{C}. \Code{A} and \Code{B} are defined as a cubic region whereas C is defined as a cylinder. I want the robot to search all three regions for objects of interest while in parallel reporting what they find to base at least once a minute. The robot can perform \Code{A} and \Code{B} in any order, but can only search \Code{C} after finishing the former two. After searching all three areas, the robot needs to return to one of several potential pickup points, which one does not matter but the robot must get there before noon the day after tomorrow and must not arrive at the pickup point before midnight of the current day. In addition, region \Code{C} must be searched before 8 pm tonight.}
\end{flushleft}


One can specify this mission in the MSL quite easily and MPFL will be able to develop a set of schedules to solve it. In fact, it does not matter how complicated the mission is, MPFL will try to solve it without violating constraints. In the event the task is impossible or tasks conflict, MPFL provides constructs to handle the situation both within the framework and within the MSL. In addition to being expressive, the MSL like other programming languages has a notion of types as well as exception handling. These features help users create specifications that are both clear and correct.

\subsection{Customization and Reusability Via Plugins}
The core MPFL library is not a complete out-of-the-box solution for planning by itself. To use MPFL, developers must build or acquire prebuilt plugin modules known as \Definition{planners} that define and implement some of the primitive scheduling capabilities of the robot. Planners are plugins for the compiler/runtime (\RefPicture{plannersareplugins.png}) that are responsible for solving a set of problems of a specific type, and generating a schedule to solve all those problems\footnote{For those that have encountered the term \textit{planner} in AI literature, the term has a different connotation as used here. Chapter 7 talks about this more.}. The planners are not provided with the compiler/runtime, but are intended to be created by a third party, most likely the vehicle software developers.  of the language.

\InsertPicture{plannersareplugins.png}{0.45}{Planners are plugins for the MPFL compiler/runtime that define primitive capabilities of the robot.}

To implement a planner, MPFL provides an object-oriented application programmer interface API which requires subclassing from a set of provided base classes. Users pass a set of planners (in the form of objects) to MPFL in addition to their mission specification when initializing the framework from the client. These planners are linked into the MPFL runtime in an analogous fashion to how drivers are linked into an operating system kernel on system bootup. Just as drivers provide the means for the kernel to communicate with the computer's components and peripherals, planners provide a means to the MPFL runtime for scheduling tasks. However by no means are building planners as difficult as writing an operating system driver and requires only implementing a handful of typed callback functions. MPFL's API is designed to be easy to understand and use while additionally providing safeguards to prevent the programmer from implementing a faulty planner. It will be shown later that not only do planners allow one to customize the underlying semantics of the MSL, but also to mix and match planners transparently without having to recompile or relink code.

Planners are what give the MPFL framework its reusability feature. Once someone implements a planner, it can be reutilized in another vehicle (with certain restrictions detailed in later chapters) in a transparent manner without recompiliation. The MPFL framework isolates planners from each other as completely sandboxed systems; this is what makes planners reusable across vehicles. Hence, once a sufficient collection of planners has been created, a vehicle developer can mix and match previously developed planners (even those made by other people), along with any new planners the vehicle requires. Make no mistake, the MPFL compiler/runtime by itself really does not do much in terms of planning. The planners do the hard work of solving the problem; the compiler/runtime itself just provides a well-defined framework that create the bridge between the MSL and planners, such as facilities for verification, error handling, and the actual delegation of problems to planners. A planner developer does not have to worry about the details of how the compiler/runtime works or how any other planners work. All they are focused on is writing their specific planner.

\subsection{A Software Framework}
The MPFL library implements a \Definition{software framework} in contrast to an ordinary library which is typically a collection of types and functions that can be used by an application. A software framework distinguishes itself from a normal library as it utilizes \Definition{inversion of control} where control flow of the program is managed by the framework rather than by the one dictated by the user. The client interacts with the framework via callback functions/methods that are fired by the framework as necessary (triggered by some event), but the framework dictates the thread of execution. For example, most widget toolkits such as \textit{Qt, Gtk+, WinForms, WxWindows}, and \textit{Swing} used for creating GUI applications follow this style; the programmer relinquishes control of their application to the framework. As GUI events occur such as resizing the window or clicking on a menu, the framework invokes callback functions/class methods to handle the events. If a user does not provide a callback then typically a default version is used. The advantage of frameworks is that they allow one to more rapidly develop software as it provides guide rails for building an application and good defaults for unspecified behavior. 

\section{Segue: A Language of Planning}
In order to understand how the MPFL compiler/runtime and planners work, the first step is to understand the MPFL MSL. The next chapter describes the MPFL MSL and informally explains the constructs in terms of language syntax and semantics, and how they came to be. Later chapters will focus on how the MPFL runtime compiles user specifications written in the MSL, and the significance of planners in the framework.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "mythesis"
%%% End: 
