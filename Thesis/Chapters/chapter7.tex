% Chapter 7 - Master's Thesis 
% Mirza A. Shah

\chapter{Results, Related Work, Future Work}
This final chapter discusses the outcomes of this research.

\section{Results}
The implementation of MPFL yielded some very interesting results and some fresh perspectives on autonomy software development. During the course of the research, a prototype MPFL compiler was developed in OCaml along with a set of prototype planners and knowledge base as described in the previous chapter.

\subsection{Mission Performance}
This prototype system demonstrated deliberative autonomous control of a simulated AUV via a specification written in the MSL without violation of constraints, even in complex scenarios. In general, the AUV not only did not violate any constraints, but performed optimally (or at least close to it) by minimizing use of resources (time and power) thanks to the heuristics implemented in the planners. In the cases of failures to find feasible schedules, MPFL's exception handling mechanisms gracefully allowed the engine to continue. It was interesting to watch the virtual robot do its best to complete tasks  and the decisions it had to make when it could not attempt certain tasks.

\subsection{Computational Performance}
The simplicity of MPFL results in negligible performance overhead from the framework itself. The computational burden is primarily dictated by the performance of each planner's scheduling algorithms. The algorithms used in the prototype example planners all run in worst case polynomial time. The most complex algorithms reside in the \Code{UseAcoustic} and \Code{UseAutopilot} planners where planners iteratively solve their problems, where the number of iterations per compilation cycle are limited. 

\subsection{Ease and Quality of API and Framework}
In software engineering, developing good software frameworks and their corresponding APIs can be extremely difficult. Though what makes an API and framework \textit{good} is subjective, generally desirable features are:

\begin{itemize}
\item \textbf{Simplicity} - Minimizing the set of functions/methods, classes, and types the user has to learn so as not to confuse or overwhelm them.
\item \textbf{Consistency} - The API should have a consistent feel so that once the user starts learning a part it, they can intuitively figure out the rest as it `follows the same formula'.
\item \textbf{Match Implementation Language Style} - If the API is implemented in a functional language, the API should have functional style versus another style such as imperative.
\item \textbf{Use Implementation Language Well} - The API should take advantage of the features of its implementation language. For example, if the language is statically typed, the API should use types extensively in API functions and callbacks to provide static verification.
\item \textbf{Modular} - The API and framwork should be broken into pieces that can be reasoned about in a piecemeal fashion so as to make it easier for the end user to learn and understand. These pieces can come through the abstraction and encapsulation constructs provided by the implementation language such as files, classes, functions, and abstract data types.
\item \textbf{Documentation} - A good API should be well documented, with descriptions for all types and functions, preconditions, and caveats. The names of functions/methods and types should be simple and self-documenting, meaning that the name implies what the function/method/types does.
\item \textbf{Verification and Feedback} - All user interactions with the framework should be verified, with static verification preferred over runtime verification. In the event of errors, the user should be informed in the simplest and clearest way possible without sacrificing crucial details.
\item \textbf{Default Behavior} - Good software frameworks allow users to take off quickly by providing default behavior with good presets. For example, in most widget toolkits, the user does not have to define the behavior of what clicking the close button on a window does --- it simply exits the program. However, the user can override this behavior by providing an alternative handler callback function to change that behavior.
\item \textbf{Isolation of API/Framework and End User Application} - A good software framework hides its implementation details from the user so that they do not have to understand how it works when building their application, nor can they modify the code of the framework and API.
\end{itemize}

MPFL was designed with all these qualities in mind. The extent to which the prototype implementation bears these qualities is subjective. However, each one is discussed below and the approach taken to incorporate those ideals into MPFL.

\subsubsection{Simplicity}
The end user only has to learn the MSL and two global functions (\Code{initialize\_mpfl} and \Code{build\_schedules}) assuming that they are not building any of the planners or knowledge base themselves. The MSL itself was designed to be minimal as can be seen from previous chapters. For users that have to write the planners and knowledge base, they additionally have to know three class hierarchies (\Code{$\alpha$ planner}, \Code{knowledgeBase}, \Code{planInstance}, and a little over a dozen variant types used to encode plan instance information such as problem specification and lifetime state. 

\subsubsection{Consistency}
The constructs in the API follow a consistent style in naming conventions. The MSL itself uses a consistent style everywhere, most notably the arguments to constructors which follow the \Code{$<$fieldName$>$ = $<$value$>$} formula. The types and values in the MSL match those found in the API. For example, plan instances in the MSL map one-to-one to the plan instances used in the planner API defined by the \Code{planInstance} class hierarchy.

\subsubsection{Match Implementation Language Style}
The MPFL compiler internals were implemented in a functional style as OCaml is primarily a functional language. The API uses functional style, but also incorporates object-oriented constructs which does not break the style as OCaml is also an object-oriented language. The imperative features of OCaml were rarely used and the majority of the code is written in a pure functional style (i.e. no side-effects) making it easier to reason about semantics and code correctness. The API is purely functional meaning that the user cannot corrupt system state via side-effect unlike languages such as C.

\subsubsection{Modular}
One of the key goals of MPFL was to make it highly modular with as few dependencies as possible between modules. This allows for reusability of components as well as making it easier to reason about system design as it can be done in a more piecemeal fashion. The components that users build are planners and knowledge bases. These modules are decoupled from each other. Though planners may create subproblems for other planners, the implementation of those planners does not matter. The user is free to couple modules together if their application requires it, though coupling should be minimized. 

\subsubsection{Documentation}
It is difficult to use any API without documentation. In MPFL, the implementation and API source code have all functions and types annotated with documentation. The documentation uses OCaml's documentation system enabling interactive help with IDEs that can pop up help information as functions, methods, and classes are used.

\subsubsection{Verification and Feedback}
If there is any philosophy that is at the core of MPFL's design, it is that everything must be verified and the user must be given meaningful feedback when problems occur. Every level of MPFL -- the MSL, the compiler/runtime, and the API -- verify as much information as possible to ensure correct operation of the robot. Missions described with MSL are guaranteed to be sensible to the robot thanks to the static and runtime checks performed by the compiler. If there are errors in the specification, MPFL will return detailed information with line number containing the violating code. The compiler/runtime is also constantly checking its own internal state to ensure that the implementation is correct and will inform the user if there is a bug in the implementation. Finally, when users build planners and knowledge bases, they have to follow a design contract dictated by the abstract base class definitions and enforced by the OCaml type system. 

\subsubsection{Default Behavior}
It is quite easy to immediately start writing code with MPFL as there are default implementations of all callback methods the user has the ability to override. One can start with a set of \textit{empty} planners where callbacks return empty values and slowly build up their components.

\subsubsection{Isolation of API/Framework and End User Application}
It is important for a good API to hide its internals from the user as well as stop the user from corrupting internal state of the compiler/runtime. In MPFL, the user does not have to have an understanding of how the internals of the compiler/runtime (i.e. Parser, LST Evaluator, PI Evaluator, etc) work. All they have to understand is the planner and knowledge base API. The pure functional style of the implementation makes it impossible for the user to corrupt system state as they cannot create a side-effect on the system.

\section{Issues and Future Work}
MPFL is a prototype system of a new software architecture for robotics planning, so it has its issues as well as plenty of potential interesting areas of further study.

\subsection{Incomplete Features}
The current implementation of the MPFL compiler is a complete working system, but to date not all features were implemented due to a lack of time. 

\subsubsection{Power Constraint Enforcement}
The astute reader may have noticed that power constraints were not enforced along with the time constraints in the PI Evaluator. Implementing power constraints is straight forward and similar to the way time constraints are enforced. Each schedule has additional columns for power and energy used by each command. Planners have the responsibility of determining an estimate for peak power and total energy. The PI evaluator validates that power and energy usages is within the constraints, if so the schedule is valid, otherwise the runtime raises an exception indicating the planner is faulty.

\subsubsection{Easily Swappable Planners}
One of the intentions of MPFL is to allow users to swap out planners and knowledge bases without the need for recompilation. For example, one could login to the robot's computer running an MPFL client, shut it down, transfer a new planner in the form of a binary blob to the robot, restart the client, and the robot would now be using the new planner. Currently, one can do this by building their individual planners/knowledge bases as runtime libraries (i.e. shared objects in Unix/Linux, dynamical link libraries in Windows) which can be dynamically linked when the client application is loaded. OCaml supports this feature as does every OS it runs on. The user however needs to be responsible for unloading the library from memory using whatever means the OS provides before running the program again so as to make sure the OS runtime linker chooses the newer version. This can be a bit painful, so in the future it would be helpful if MPFL could provide additional abstractions to make swappable planners easier. Note that there is no intent to ever make \emph{hot swappable} planners as it does not make too much sense in the MPFL thought process and would likely make the system unnecessarily complex.

\subsection{Problems with Distributed Planning}
The modularity and component isolation afforded by planners and knowledge bases comes at a cost. MPFL is a distributed planning system, where each planner independently schedules its own problems. Though there is coordination between parent and children planners through the planner graph, there is no way to finely coordinate the actions created by one planner with the actions created by another. For example, the example \Code{Search} planner from the previous chapter creates problems for the \Code{Transit} and \Code{UseSonar} planners. The only coordination between the two comes through the use of the parallel (\Code{||}) operator. The parallel operator switches either the \Code{Transit} or \Code{UseSonar} plan instances into an \Code{On(FORCE\_RUN)} state as soon as the other goes into an \Code{On(RUN)} state. There is no fine-grained coordination between the two tasks, which may be desired. Users can get around this by coupling planners when they implement them. Though this breaks the spirit of the MPFL concept and the independence of planners, it is a reasonable way to approach the problem if needed.

Additionally, a planner in MPFL only creates a single schedule though multiple schedule options may be available (i.e. there is more than one way to accomplish the same set of tasks). When a planner creates subproblems for its children planners, the scheduling algorithms of the children maybe able to generate multiple scheduling solutions. This could mean that the parent planner may have a preference for one schedule over the other, though any schedule that does not violate its constraints will do. This is a slightly more difficult feature to enable as now the planner implementor has to think about the possibility of creating multiple schedules, and also deciding which schedule from its children planners work best. What is more problematic is if a planner has multiple parents, in which case they must arbitrate over which planner is the best. One solution to implement this feature is utilize \Definition{cost functions}, where planners can feed their children a higher-order function that can return a score of \emph{goodness} that the planner can use to choose the best schedule that optimally meets the requirements of all the parents.

\subsection{The Use of OCaml and Bindings for Other Languages}
An early prototype of MPFL was written in the C++ programming language. The reasoning behind that decision was that C++ would provide not only better performance than other high-level languages, but that an object-oriented API in C++ would be more appealing to roboticists as it is a highly used language in the robotics field, is supported on a large number of platforms including many microcontrollers, and can be easily mixed with C code which is also highly used. This approach was abandoned as C++ proved to be a burdensome metalanguage for language development, primarily because of the amount of boilerplate code required, the lack of garbage collection, the lack of pattern matching, and clunky versions of common data structures such as dynamic arrays (vectors), linked lists, and hash tables. The compiler in its completed state along with the API took around 50,000 lines of C++ code when completed. 

The prototype proved difficult to debug or alter due to its sheer complexity. It could be blamed on poor design, though a lot of effort went into it. Eventually the compiler was reimplemented in OCaml, where it took fewer than 1500 lines of code and is much easier to read. This is not surprising as the ML family of languages is excellent for prototyping languages\footnote{ML is an acronym for \textbf{`m}eta\textbf{l}anguage', implicative of its intended use.}. The use of pure functional style allows for code to be flexible as one does not need to worry about side-effects so pieces can be moved around without worry as the code develops. The strong type system, rich standard library, garbage collection, higher order functions/closures, variant types, easily manipulatable linked lists, and pattern matching on variant types and lists also made OCaml the perfect choice. The OCaml compiler also generates good quality code in terms of performance and is considered one of the best in the functional language world. According to OCaml's creator, Xavier Leroy, the OCaml compiler generates code that will typically run no worse than 50\% the speed of an equivalent C program utilizing a decent compiler \citep{leroy:ocaml}. In the end, it turned out that even unoptimized debug code with OCaml's bytecode compiler (rather than its native compiler) ends up providing sufficient performance anyway as the overhead of the MPFL framework is minimal.

Though OCaml was a great choice to implement MPFL, having an API in OCaml is not a good practical choice. This is due to its lack of popularity along with the general lack of experience in the functional programming paradigm in non-academic settings. This is unfortunate as the planners implemented for the demonstration were extremely simple -- the most complex being the \Code{UseAutopilot} planner with 300 lines of code. However, we must deal with reality. Therefore we propose to utilize OCaml's C foreign function interface to implement a C binding for the API. The interface is already being utilized to link in some basic C libraries required for the demonstration planners and it is quite straightforward. Once the C binding is written, bindings for other popular languages can be written as virtually every programming language has a way to call C functions, including Java, Python, Matlab, and C\#. C++ can inherently call C functions. By creating a variety of bindings for MPFL, the framework becomes accessible to a much wider audience. The compiler/runtime is still implemented in OCaml and the benefits provided by it remain.

\subsection{Metalanguage}
The original intent of MPFL was to be specific to autonomous underwater vehicles. However, during its development it was realized that it could be applied to any autonomous system. All that ties MPFL specifically to AUVs is the various primitive plans provided by it (e.g. \Code{Loiter}, \Code{Search}, \Code{UseAutopilot}). The primitive plans are not inherently tied to MPFL, in fact the compiler/runtime has no understanding of the problems its managing other than the time and power resources they use and are constrainted to. In other words, MPFL treats all plan instances equivalently, it just uses the type of plan instance to route it to the correct planner when the PI Evaluator is invoked.

The set of primitive plans and their plan instance constructors that currently exist are not completely realistic or finalized. However, rather than attempting to define those primitives, it would make more sense to allow users to add and remove their own primitive plan types with corresponding constructors. The concept is simply a generalization of the current implementation. For example, if one wanted to add a new primitive plan such as \Code{UseWeapon} which allowed the robot to fire a weapon, they would now have the ability to do so along with naming the fields and their corresponding types that go into the new plan's plan instance constructor. 

Implementing this feature is quite straightforward and requires implementing a \Definition{metalanguage} that allows users to define all the primitive plans that their MPFL compiler/runtime understands along with their constructor definition. A compiler for the metalanguage will then generate the OCaml code for all the appropriate class types (i.e. customized planner API) and build a custom version of the MPFL compiler/runtime for the MPFL client to link against. 

\subsection{Graphical Tool}
Though the use of a programming language to control the robot (the MSL) is powerful and appealing, it is likely that many end users will not want to control their robot via a programming language. For example, a researcher may develop a robot that uses MPFL  in military applications, but a soldier or sailor will not want to write a program when in the field. The intent of the MSL was never to be used by non-technical people, but rather as a middleware layer to communicate with a robot. Instead, what is proposed is creating a graphical tool where users can describe the tasks they want to do as a tree (\RefPicture{mpfl_potential_gui.png}). Nodes in the tree represent tasks and children nodes are subtasks. Sibling nodes can be related using a planning operator (e.g. $>$, $||$, \^{}, \&) or via a condition. Users can also bind constraints to a branch of the tree. Essentially the user would be visually creating the plan instance tree, which itself can directly be translated into an autogenerated yet easy to read MSL program. This program can then be fed into the MPFL compiler manually or directly through the GUI tool.

\InsertPicture{mpfl_potential_gui.png}{0.25}{Mockup of a potential MPFL Graphical Tool}

\subsection{Enhancing MSL}
There is much to be desired from the MSL in terms of features. 

\subsubsection{Syntax}
The syntax of the language is a bit verbose and can make it difficult to read code, so it may make sense to reevalutate it. The heavy use of parentheses can also become frustrating. 

\subsubsection{Primitive Plan Types}
As mentioned earlier, a metalanguage should be created to encode different types of primitive plans and their corresponding plan instance constructors. However, until such a feature is added, the current set of primitive plans are not completely desirable for a real AUV. For example, there are many types of searches an AUV can perform and additional parameters that define the search besides an area, a sensor, and a lanewidth. It is quite easy to add in new primitive plan types, however it requires modifying the implementation code which the end user should not touch.

\subsubsection{Better Lookup Calls and More Built in Functions}
The current set of \Code{Lookup*} calls in the MSL only cover the four primitive types: boolean, integer, floating point, and string. In addition to these types, there should be lookup calls for all MSL types, such as \Type{position} and \Type{angle}. This is an easy extension to add and just requires the user to add more lookup calls to their knowledge base implementation. In addition to being able to lookup values, it would be handy to be able to perform some common functions with them. Just as one can perform basic arithmetic with floating points and integers in the MSL and can compare equality of the string, calls for calculating the distance between two \Type{position} values or getting the value of a \Type{duration} value in minutes can be useful in the MSL, particularly with conditional expressions.

\subsubsection{Variables and Functions}
Adding variables and functions to a language, as found in most high-level languages, is quite straightforward. However, this feature was never added into the MSL as the point was to make it as narrow in scope as possible. Adding functions and variables would make the MSL look more like a general-purpose programming language than a domain-specific one, diluting its purpose and making MSL programs unnecessarily complex. However, adding these features may not necessarily be a bad idea; if the MSL becomes powerful enough to be used in general programming, there may come a point where the MPFL client application is no longer needed or at least much smaller in size. Though it is unlikely the MSL will ever add these features, it is interesting to ponder what effects it could have.

\subsection{Real Usage and System Tuning}
Though this thesis puts MPFL in a positive light, the system has only been tested in simulation and to a limited extent. To prove its worthiness, MPFL needs to be used on a variety of robots, by a variety of different people.  This real life usage will help provide feedback about its usefulness. If there are shortcomings, they should be addressed as found. 

\section{Related Work}
MPFL is one of countless architectures for autonomous planning and not the first to use a domain-specific programming language. The approach however was unique in that the focus was on a very practical and simple software tool where a robotics software engineer could learn the MSL and MPFL API in a few hours and generate highly-verified and deliberative autonomy in contrast to other tools which often can be a bit overwhelming or only applicable to a set of toy problems. However, MPFL was inspired by many of these alternative architectures, and it is prudent to take a look at the other approaches, their advantages, and their shortfalls.

\subsection{Planners}
Those that come from an AI background will likely have a different association with the term \emph{planner} than the way it is used in MPFL. In the AI world, `planners' are similar to the notion of a planner in MPFL in that they are entities that take a set of tasks and a set of constraints and output a schedule of actions. The difference is that in AI, planners usually also take with them a \emph{start state}, a set of \emph{end states}, and a set of valid \emph{actions} similar to those in a finite state machine. In the AI world, planners are algorithms which figure out a schedule of actions to get from the start state to the end (i.e. goal) state. In other words, planners are simply general purpose constraint solvers where the user encodes the problem, the goals, and the valid actions that can be taken by the entity for which the schedule is being generated (e.g. a robot) \citep{russellnorvig:ai}. MPFL does none of this. Rather it just tells the user to implement a scheduling algorithm for each particular task within the domain. MPFL just provides you with the information needed to schedule, but does not figure out how to schedule the task. Though this may seem like a lacking in MPFL, it was done on purpose because attempting to generalize planning is not a fruitful endeavor in the opinion of the author. Though it is interesting and potentially more useful, in practice general purpose planners have only been able to solve toy problems efficiently. Though more complex problems can be solved, they typically become intractable due to the inefficiency of the solver which is essentially building a proof tree to get from the start state to the goal state. The author thinks it makes more sense to write scheduling algorithms for specific scheduling problems as they occur, which is exuded by the various types of planners that one can create in MPFL. As an example, the way the demo \Code{UseAutopilot} scheduler works with a genetic algorithm is much different than the way the demo \Code{UseAcoustic} planner utilizes a linear program. 

\subsection{Languages for Planning and Robotic Control}
Though MPFL takes a different and more limited approach to planning than the generalized planners that are the focus of AI research, there is one thing in common: the use of a domain specific programming language. Many popular planners utilize a language which allows users to describe the tasks they want to perform along with constraints, but also allowing constructs for encoding valid actions, start states, and goal state. The use of languages to encode and reason about plans has been prevalent since the days of PLANNER \citep{hewitt:planner}. Popular languages include STRIPS \citep{fikes:strips, fikes:stripsretrospective} and PDDL \citep{mcdermott:pddl}. \citet{simmons:tdl} describes an extension to the C++ language called TDL that enables specification of robotic tasks. \citet{gat:esl} describes ESL which is a planning language for embedded autonomous agents. Likewise, numerous languages specifically for reactive robotic control/planning have also been created such as COLBERT \citep{konolige:colbert} and RPL \citep{mcdermott:rpl}. \citet{peterson:frob} describes a declarative language for robotic control which is the most similar concept to MPFL found in the literature. \citet{eberbach:CCL} describes a common control language with emphasis on the control of multiple autonomous vehicles.

\subsection{Robotic Software Architectures}
A \Definition{software architecture} is a ``methodology for structuring algorithms" \citep{russellnorvig:ai}. An architecture encompasses the building blocks for building systems following a common design philosophy. These building blocks can be in the form of software tools, frameworks, APIs, and languages. A \Definition{robotic software architecture} is a software architecture for the software that runs onboard a robot, what we have referred to as the robot's autonomy software stack. A robotic software architecture can be used to help build robotics software more rapidly. MPFL can be considered one piece of a robotic software architecture with a focus on mission planning and resource allocation. 

\subsubsection{Design Philosphy: Reactive, Deliberative, Hybrid}
Robotic software architectures can be described as being, reactive, deliberative, or a mix of the two (hybrid). The first chapter described the terms \emph{reactive} and \emph{deliberative}. The more reactive a robot is, the less analysis it makes about its next decision. In other words, it thinks less about the long-term consequences of its actions and does not think much about its past experiences. The model is essentially a simple stimulus-response mechanism. The more deliberative a robot is, the more it thinks about its actions based on past information and predictions of the future. Hybrid systems are ones that utilize both philosophies where appropriate for the robot's application \citep{alami:archforautonomy, gat:onthreelayer}. Planners (both in the traditional AI sense and MPFL planners) tend to follow a deliberative philosophy. On the other end of the spectrum, one of the best examples of a reactive system is the \Definition{Subsumption Architecture} created by MIT researcher Rodney Brooks \citep{brooks:subsumption, brooks:newapproach}. The premise in Subsumption Architecture is to create an $N$-level tree of \textit{behaviors} (which are analogous to the planners in MPFL). The behaviors higher up in the tree represent high-level aspects of the robot's intelligence (such as performing a search) whereas the lowest levels represent the most primitive abilities of the robot (e.g. sending power to the servo to move the robot). The higher level behaviors are performed by breaking up the problem into a series of input for the children behaviors (i.e. higher level behaviors \textit{subsume} children behaviors). For example, if we think of the task of driving a car in terms of Subsumption Architecture, the highest level behaviors could pertain to managing the high level goal of getting to a particular destination and the lower level behaviors deal with the actual impulsive movements that must be made to the steering wheel and accelerator to accomplish the higher level goals. Subsumption Architecture and its variants are sometimes referred to as \Definition{behavior-based autonomous control systems} \citep{arkin:behaviorbasedrobotics}.

What makes the Subsumption Architecture reactive is that the behaviors in the tree are simple functions that take an input from higher level behaviors indicating what needs to be done and in turn causes those behaviors to create further input for its children. The behaviors are stateless and simply reacting to input. The idea is that if one combines enough of these simple behaviors together, a more complex overall \Definition{emergent behavior} will be exuded by the robot. For example, if you look at the way a flock of birds flies, the exhibit complex behavior as they fly together in perfect formations without explicit communication. Each bird is following a simple set of rules: \textit{stay a certain distance to the bird to your left, to your right, and the one in front of you}. Robots can also follow simple rules like this and exhibit complex control. In fact this is the very approach used in iRobot's \textit{Roomba} vacuum cleaner robots, and it is no surprise that Chief Technology Officer (CTO) of iRobot happens be Rodney Brooks. Brooks' philosophy has been controversial, many agree, many do not. It has been found in practice though when more and more complex behavior is required, simplistic reactive control systems are limited and more complex logic is needed.

In practice, robots tend to use a hybrid approach such as the \Definition{three layer architecture}. In this model, three abstraction layers are used: \textit{reactive}, \textit{executive}, and \textit{deliberative}. The reactive layer sits closest to the hardware and performs the more impulsive tasks, such as orienting a wheel to face a certain direction. This layer needs to be really fast and typically implemented using concepts from the field of \textit{control theory}. The deliberative layer focuses on the high level mission and tasks it composes and sending commands to the reactive layer to perform the mission. The executive layer is simply a glue layer between the two which does the mediation. MPFL is not a complete autonomy solution, but works well as the deliberative layer in a robot using a three-layer robotic architecture.

Though MPFL is a deliberative system, it was ironically inspired by Subsumption Architecture. The planner graph in MPFL is based off the idea of Subsumption Architecture's $N$-level behavior tree. Planners are analogous to behaviors, but rather than being simple stimulus-response objects, they are deliberative schedulers. However, the notion of breaking down the problem and delegating it to lower level entities remains. This idea is nothing revolutionary, rather it is just another instance of layering as is found throughout all of computer science. MPFL was also not the first planning system to think of this, as many planners and scheduling systems use this. The technical term is \Definition{hierarchical planning system} as the system is broken into many layers where high level tasks are broken into smaller ones for lower layers. As each planner operates independently of each other, MPFL is also a \Definition{distributed planning system} or equivalently a \Definition{multi-agent planning system}.
 
\subsubsection{Robotic ``Operating Systems''}
It was implied in previous chapters that MPFL itself can be thought of almost as an operating system for a robot. The idea of thinking about creating an abstraction layer for robots which provides services to robotic software developers the way an operating system provides abstractions to its application developers is nothing new. Virtually every sufficiently complex robotic software architecture can be interpreted as being a robotic operating system. There are however robotic software architectures out there that attempt to be robotic operating systems. These systems act as an intermediary between the application-specific code and the robot, providing APIs for commonly needed tasks in robotics including message passing, navigational calculations, data fusion algorithms, device driver-style hardware abstractions,and data logging and playback. Examples include:

\begin{itemize}
\item \textbf{Mission Oriented Operating Suite (MOOS)} - MOOS is a set of simple tools written in C++ at Oxford University and MIT for autonomous robot applications \citep{newman:moos}. MOOS allows one to break up their autonomy software stack into several processes, each one able to communicate with each other by publishing and subscribing to data feeds available to all other processes. Each process is synonymous with an agent in a multi-agent system. MOOS comes with a set of prebuilt agents for data logging, navigation, debugging, and talking to various hardware devices. MOOS is free, open-source software with comprehensive documentation. The MPFL demo system utilizes MOOS for interprocess communication.
\item \textbf{Robot Operating System (ROS)} - ROS, maintained by Willow Garage, is a similar concept to MOOS, but goes beyond it by trying to provide not only the basics, but additional tools used in modern robotics such as computer vision algorithms, robot simulators, and motion planning for robotic arms \citep{quigley:ros}. ROS is free, open-source software and well documented.
\item \textbf{Microsoft Robotics Studio (MRS)} - MRS is a robotics development tool created in 2006 by Microsoft Corporation. Robotics Studio provides a framework for building individual \textit{services} where each service is an agent in a multi-agent system. For example, a robot can have a service for managing the camera, one for controlling speed, one for managing the mission, and one for a wireless Bluetooth connection. A message passing system with standardized messages allows users to write the glue code in any .NET-based language. In addition to the framework for building the robot's autonomy, MRS comes with a simulator and real-time 3D visualization tool for mapping the robot's movements. Microsoft's goal with Robotics Studio is to standardize robotics software leveraging their influence in the information technology world \citep{jackson:msrobotics}. Though a great idea, Microsoft's development efforts are focused on their Windows operating system platform, as consistent with their philosophy. This is limiting as it creates proprietary lock-in and excludes the efforts of the open source software community. The latter is very problematic as open source software such as Linux-based operating systems and the GNU compiler collection (gcc) are ubiquitous in the robotics world. On the other hand, MRS' development tools are very well-designed and easy to use allowing software developers familiar with Microsoft's .NET framework to quickly take off.
\item \textbf{Coupled Layer Architecture for Robotic Autonomy
(CLARAty)} - CLARAty is a robotics architecture developed through a collaboration between Jet Propulsion Laboratory, NASA Ames Research Center, Carnegie Mellon University, and the University of Minnesota \citep{volpe:claraty}. CLARAty also utilizes a multi-agent approach like MOOS, ROS, and MRS. A limited subset of the CLARAty code is available to the public under a limited open source license.
\end{itemize}

\subsection{Cognitive Architectures}
\Definition{Cognitive architectures} are software architectures that attempt to model the human mind or an equivalent there of. These architectures are not developed with the focus of controlling an autonomous robot, but rather to understand the nature of the human mind and human intelligence. The design of these systems is based on theories of how the mind works from cognitive science. As mentioned in the first chapter, cognitive science is a relatively new field that incorporates many disciplines including computer science, artificial intelligence, biology, neuroscience, and psychology. Though cognitive architectures were not meant to run on robots, many of the problem solving capabilities that have emerged from the development of these architectures have crossed over into the autonomous robotics realm. As mentioned in chapter 2, better autonomy implies more intelligence, so it is not surprising that successful cognitive architectures have been applied to autonomy problems. \citet{vernon:surveyofcognitivesys} presents a fairly thorough history and comparison of various cognitive architectures. Three of the most well known cognitive architectures are:

\begin{itemize}
\item \textbf{Soar} - Soar is a cognitive architecture, created by John Laird, Allen Newell, and Paul Rosenbloom at Carnegie Mellon University and now maintained by John Laird's research group a the University of Michigan. Soar is the successor to Herbert Simon and Allen Newell's \textit{General Problem Solver (GPS)}, and meant to be a software implementation of the cognitive model Newell described in his book \textit{Unified Theories of Cognition} \citep{newell:unifiedtheories}. Soar utilizes a programming language based approach where users encode both the intelligent agent's knowledge representation and reasoning through the use of production rules similar to those in a logic based language. Soar is similar to the notion of the classical AI planner mentioned earlier, but attempts to avoid problems like rule explosion by introducing metarules that allow the system to cache and stereotype information. \citep{lehman:gentlesoarintro, laird:extendingsoar, laird:soarmanual}
\item \textbf{ACT-R (Adaptive Control of Thought - Rational)} - ACT-R is a cognitive architecture created by John Anderson at Carnegie-Mellon University and also uses the rule based approach of Soar. It was inspired heavily by Soar and Newell's book \textit{Unified Theories of Cognition} \citep{newell:unifiedtheories}. Unlike Soar though, rather than using its own programming language, ACT-R is simply a big collection of Lisp functions that the user utilizes in their client application. \citep{anderson:acttheory, anderson:actr}
\item \textbf{EPIC (Executive Process - Interactive Control} - EPIC is a cognitive architecture developed by  David E. Kieras and David E. Meyer at the University of Michigan. EPIC is different from other cognitive architectures as it has a focus on perceptual and motor capabilities making it particularly useful in \textit{Human-Computer Interaction (HCI)} applications. EPIC is similar to ACT-R in that it is both a rule-based system and is presented a collection of Lisp functions.\citep{kieras:epic}
\end{itemize}

\section{Conclusion}
In practice, the high-level tools such as classical planners and cognitive architectures have only been able to solve problems in a niche area as they either fail to scale to a more general set of problems or do not have the means of solving problems relevant to autonomous robots. Tools such as the ROS and MOOS fall on the other end of the spectrum and are used quite heavily in practice, but the burden of implementing the high-level intelligence is put on the user of the tools. What makes MPFL unique however is that it tries to find a sweet spot between the practical and the theoretical. MPFL was meant to help robotic software developers move up another level of abstraction from the facilities that ROS and MOOS provide, yet build their planning software in a way that is consistent, correct, fast, easy to reason about, and reusable. Classical approaches have failed because their goals are too lofty: creating a general-purpose planning algorithm. It makes more sense to allow users to build several simple, yet smarter and more efficient domain specific schedulers (i.e. MPFL planners). Though the idea of distributed and hierarchical schedulers is not new, MPFL provides a common framework for building these schedulers which allows for verification at every level along with an extremely powerful and declarative language for controlling the robot. The language is what makes MPFL shine; one can specify the most convoluted and complex mission they can think of, and MPFL will attempt it without violating any constraints. This is remarkable given that from the robotic software developer's perspective they are building simple isolated components, but then are able to get a complex, emergent behavior out of it through the language.

MPFL is not meant to be a silver bullet for solving all problems pertaining to planning in autonomous robots. It does not contain in it anything that the robotics and artificial intelligence communities have not yet seen. However, it tries to take existing concepts and structure them in a particular way using the discipline of software engineering in order to create a tool that is useful in real-life robotics applications to real-life software engineers. At the very least, MPFL creates a fresh perspective on the implementation of robotic autonomy.









%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "mythesis"
%%% End: 
